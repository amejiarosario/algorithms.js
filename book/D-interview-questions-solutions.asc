[appendix]
[[d-interview-questions-solutions]]
== Interview Questions Solutions
(((Interview Questions Solutions)))

=== Solutions for Array Questions
(((Interview Questions Solutions, Arrays)))

:leveloffset: -1

[#array-q-max-subarray]
include::content/part02/array.asc[tag=array-q-max-subarray]

The first step is making sure we understand the problem well. Let's do basic examples:

----
A = [-5, 6, 9, -8]
B = [-1, 6, -3, 8]
----

What's the subarray with the maximum sum? For A, it will be `[6, 9]` and for B, it will be `[6, -3, 8]`.

We could generate all possible subarrays, add them up, and then pick the max number.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=maxSubArrayBrute1]
----

This code is simple to understand; however, not very efficient. The runtime is `O(n^3)`.

If you noticed we adding up the numbers from `i` to `j` on each cycle. But, we can optimize this. We can keep a local variable and add the new number to it. That way, we don't have to revisit previous numbers.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=maxSubArrayBrute2]
----

The runtime is much better: `O(n)`. Can we still do better?

We can use a greedy approach, where do one pass through the array. We only add the numbers if their sum is larger than just taking the current element.

[source, javascript]
----
include::interview-questions/max-subarray.js[tag=description]
include::interview-questions/max-subarray.js[tag=solution]
----

The runtime is `O(n)` and a space complexity of `O(1)`.




[#array-q-buy-sell-stock]
include::content/part02/array.asc[tag=array-q-buy-sell-stock]

There are multiple examples that we can simulate: bear markets (when prices are going down), bullish markets (when prices are going up), and zig-zag markets (when prices are going up and down).

[source, javascript]
----
// zig-zag market
maxProfit([5, 10, 5, 10]); // => 5
// bullish market
maxProfit([1, 2, 3]); // => 2
// bearish market
maxProfit([3, 2, 1]); // => 0
----

During the bearish markets, the profit will always be 0. Since if you buy, we are only going to lose.

We can do a brute force solution doing all combinations:

[source, javascript]
----
include::interview-questions/buy-sell-stock.js[tag=maxProfitBrute1]
----

The runtime for this solution is `O(n^2)`.

A better solution is to eliminate the 2nd for loop and only do one pass.

Algorithm:

- Do one pass through all the prices
    - Keep track of the minimum price seen so far.
    - calculate `profit = currentPrice - minPriceSoFar`
    - Keep track of the maximun profit seen so far.
- Return maxProfit.

[source, javascript]
----
include::interview-questions/buy-sell-stock.js[tag=description]
include::interview-questions/buy-sell-stock.js[tag=solution]
----

The runtime is `O(n)` and a space complexity of `O(1)`.



:leveloffset: +1

=== Solutions for Linked List Questions
(((Interview Questions Solutions, Linked Lists)))

:leveloffset: -1




[#linkedlist-q-merge-lists]
include::content/part02/linked-list.asc[tag=linkedlist-q-merge-lists]

For this problem we need to visit each node in both list and recontruct them in ascending order. Note: We don't need to copy the values into a new node.

Another case to take into consideration is that list might have different length. So, if one list runs out, we have to keep taking elements from the remaining list.

*Algorithm*:

- Have a pointer for each list
- While there's a pointer that is not null, visite them
    - Compare each list's node's value and take the one that is smaller.
    - Advance the pointer of the taken node to the next one.

*Implementation*:

[source, javascript]
----
include::interview-questions/merge-lists.js[tag=description]
include::interview-questions/merge-lists.js[tag=solution]
----

Notice that we used a "dummy" node or "sentinel node" to have some starting point for the final list.

*Complexity Analysis*:

- Time: `O(m+n)`. Visiting each node from the list 1 and list 2 has a time complexity `O(m + n)`, where m and n represents the length of each list repectively.
- Space: `O(1)`. We resuse the same nodes and only change their `next` pointers. We only create one additional node "the sentinel node".


[#linkedlist-q-linkedlist-same-data]
include::content/part02/linked-list.asc[tag=linkedlist-q-linkedlist-same-data]

For this question, we are given two linked lists that contains string data. We want to know if the concatenated strings from each list are the same.

The tricky part is that same data can be distributed differently on the linked lists:

----
L1: he -> ll -> o
L2: h -> e -> llo
----

One naive approach could be to go through each list's node and concatenate the strings. Then, we just need to compare them.

[source, javascript]
----
include::interview-questions/linkedlist-same-data.js[tag=hasSameDataBrute1]
----

Notice that the problem mentions that lists could be VERY large (millions of nodes). If the first character on each list are different, we are unecessarily computing millions of nodes, when one simple check will do the job.

A better way to solve this problem is iterating over each character on both lists and when we found mistmatch we return `false`. If they are the same we will go over all of them.

*Algorithm*:

- Set a pointer to iterate over each node in the lists.
- For each node, have an index (starting at zero) and compare if both lists have the same data.
    - When the index reaches the last character on the current node, we move to the next node.
    - If we found that a character from one list doesn't match the other, we return `false`.

*Implementation*:

[source, javascript]
----
include::interview-questions/linkedlist-same-data.js[tag=description]
include::interview-questions/linkedlist-same-data.js[tag=solution]
----

The function `findNextPointerIndex` is a helper to navigate each character on a linked list.
Notice, that we increase the index (`i + 1`) on each iteration.
If the index overflows, it moves to the next node and reset the index to zero.



*Complexity Analysis*:

- Time: `O(n)`. We go over all the characters on each lists
- Space: `O(1)`. Only using pointers and no auxiliary data structures.



:leveloffset: +1

=== Solutions for Stack Questions
(((Interview Questions Solutions, Stack)))

:leveloffset: -1

[#stack-q-valid-parentheses]
include::content/part02/stack.asc[tag=stack-q-valid-parentheses]

We need to validate that brackets are properly opened and closed, following these rules:
- An opened bracket must be close by the same type.
- Open brackets mush be closed in the corrent order.

This is a parsing problem and usually stacks are a good candidates for them.

*Algorithm*:

- Create a mapping of opening bracket with its closing bracket
- Iterate through the string
    - When we found an opening bracket, insert the corresponding closing bracket into the stack.
    - When we found a closing bracket, pop from the stack and make sure it correspond to the current character.
- Check the stack is empty. If there's a leftover, it means that something didn't close properly.

*Implementation*:

[source, javascript]
----
include::interview-questions/valid-parentheses.js[tag=description]
include::interview-questions/valid-parentheses.js[tag=solution]
----

*Complexity Analysis*:

- Time: `O(n)`. We iterate over each character of the string.
- Space: `O(n)`. We use an auxiliary stack.


// [#linkedlist-q-TAG]
// include::content/part02/linked-list.asc[tag=linkedlist-q-TAG]

// RESTATE REQUIREMENTS AND DESCRIPTIONS

// *Algorithm*:

// - STEP 1
// - STEP 2
//     - STEP 2.1
//     - STEP 2.2

// *Implementation*:

// [source, javascript]
// ----
// include::interview-questions/TAG.js[tag=description]
// include::interview-questions/TAG.js[tag=solution]
// ----

// IMPLEMENTATION NOTES

// *Complexity Analysis*:

// - Time: `O(?)`. WHY?
// - Space: `O(?)`. WHY?

